#!/usr/bin/env python3
"""
Cross-platform script to decrypt and extract files.
Works on Windows, Linux, and macOS.
"""

import argparse
import hashlib
import os
import shutil
import sys
import zipfile
from pathlib import Path


def parse_arguments():
    parser = argparse.ArgumentParser(description='Decrypt a file')
    parser.add_argument('--input', '-i', required=True,
                        help='Path to the encrypted input file')
    parser.add_argument('--output', '-o', required=True,
                        help='Path for the decrypted output file')
    parser.add_argument('--extract', '-e', action='store_true',
                        help='Extract the decrypted file if it is a ZIP archive')

    parser.add_argument('--checksum', '-c',
                        help='Checksum for verification')
    parser.add_argument('--secret', '-s',
                        help='Secret key used for encryption key generation')

    return parser.parse_args()


def generate_key_iv(secret, checksum):
    # Generate key using SHA-256
    key_input = f"{secret}{checksum}".encode('utf-8')
    key = hashlib.sha256(key_input).hexdigest()
    
    # Generate IV using MD5 (equivalent to the reversed string + md5sum in bash)
    iv_input = key_input[::-1]  # Reverse the bytes
    iv = hashlib.md5(iv_input).hexdigest()
    
    # Convert from hex to bytes
    key_bytes = bytes.fromhex(key)
    iv_bytes = bytes.fromhex(iv)[:16]  # AES requires 16 bytes for IV
    
    return key_bytes, iv_bytes


def decrypt_file(input_file, output_file, key, iv):
    """Decrypt file using available crypto libraries with fallback"""
    # Try cryptography first (more likely to be installed)
    if decrypt_with_cryptography(input_file, output_file, key, iv):
        return True
    
    # Fall back to pycryptodome if cryptography fails
    if decrypt_with_pycryptodome(input_file, output_file, key, iv):
        return True
    
    # If both fail, show helpful error
    print("Error: Could not decrypt file with any available crypto library.")
    print("Please install either 'cryptography' or 'pycryptodome':")
    print("  pip install cryptography")
    print("  - or -")
    print("  pip install pycryptodome")
    return False


def decrypt_with_cryptography(input_file, output_file, key, iv):
    """Try to decrypt using the cryptography library"""
    try:
        # Import cryptography modules
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        
        with open(input_file, 'rb') as infile:
            ciphertext = infile.read()
        
        # Create cipher and decrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        # Remove PKCS#7 padding manually
        padding_length = plaintext[-1]
        if padding_length > 16:  # Sanity check for padding value
            raise ValueError("Invalid padding")
        plaintext = plaintext[:-padding_length]
        
        with open(output_file, 'wb') as outfile:
            outfile.write(plaintext)
        
        return True
    except ImportError:
        # Cryptography not available
        return False
    except Exception as e:
        # Other errors during decryption
        print(f"Cryptography decryption error: {e}")
        return False


def decrypt_with_pycryptodome(input_file, output_file, key, iv):
    """Try to decrypt using the pycryptodome library"""
    try:
        # Import pycryptodome modules
        from Crypto.Cipher import AES
        from Crypto.Util.Padding import unpad
        
        with open(input_file, 'rb') as infile:
            ciphertext = infile.read()
        
        # Create cipher and decrypt
        cipher = AES.new(key, AES.MODE_CBC, iv)
        plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
        
        with open(output_file, 'wb') as outfile:
            outfile.write(plaintext)
        
        return True
    except ImportError:
        # PyCryptodome not available
        return False
    except Exception as e:
        # Other errors during decryption
        print(f"PyCryptodome decryption error: {e}")
        return False


def extract_zip(zip_file, extract_dir):
    try:
        with zipfile.ZipFile(zip_file, 'r') as zip_ref:
            zip_ref.extractall(extract_dir)
        return True
    except Exception as e:
        print(f"Error extracting zip file: {e}")
        return False





def main():
    args = parse_arguments()
    
    # Create Path objects for better cross-platform compatibility
    input_file = Path(args.input)
    output_file = Path(args.output)
    checksum = args.checksum
    secret = args.secret
    
    # Check if input file exists
    if not input_file.exists():
        print(f"Error: Input file does not exist: {input_file}")
        sys.exit(1)
    
    # Check if output directory exists
    if not output_file.parent.exists():
        print(f"Error: Output directory does not exist: {output_file.parent}")
        print("Please create the directory before running this script.")
        sys.exit(1)
    
    # Generate key and IV
    key, iv = generate_key_iv(secret, checksum)
    
    # Decrypt the file
    if not decrypt_file(input_file, output_file, key, iv):
        sys.exit(1)
    
    print(f"File decrypted successfully to: {output_file}")
    
    # Handle extraction if requested
    if args.extract:
        # Extract to the same directory as the output file
        extract_dir = output_file.parent
        
        # Extract the zip file
        if not extract_zip(output_file, extract_dir):
            sys.exit(1)
        
        print(f"File extracted successfully to: {extract_dir}")
        



if __name__ == "__main__":
    main()